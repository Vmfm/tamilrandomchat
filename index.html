<!doctype html>
<html>
<head>
  <meta charset="utf-8" />
  <title>Random Video Chat (GitHub Pages)</title>
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <style>
    body { font-family: Arial, sans-serif; background:#111; color:#eee; display:flex; flex-direction:column; align-items:center; padding:20px; }
    video { width:320px; height:240px; background:#000; margin:8px; border-radius:8px; box-shadow:0 2px 8px rgba(0,0,0,0.6); }
    #controls { margin:12px; display:flex; gap:8px; }
    button { padding:8px 12px; border-radius:6px; border:none; background:#2d8cff; color:white; cursor:pointer; }
    button.danger { background:#ff5858; }
    .status { margin-top:8px; font-size:0.95rem; opacity:0.9; }
  </style>
</head>
<body>
  <h2>Random Video Chat</h2>
  <div>
    <video id="local" autoplay muted playsinline></video>
    <video id="remote" autoplay playsinline></video>
  </div>
  <div id="controls">
    <button id="startBtn">Start Camera</button>
    <button id="joinBtn" disabled>Find Random Partner</button>
    <button id="leaveBtn" class="danger" disabled>Leave</button>
  </div>
  <div class="status" id="status">Status: idle</div>

<script>
(async function(){
  // CONFIG
  // Replace with your signaling server address (ws:// or wss://)
  const SIGNAL_SERVER = "wss://vmfm.github.io/tamilrandomchat"; // e.g. wss://example.com
  // STUN servers
  const ICE_CONFIG = { iceServers: [
    { urls: "stun:stun.l.google.com:19302" },
    // add TURN here if you have one
  ]};

  // UI
  const startBtn = document.getElementById('startBtn');
  const joinBtn  = document.getElementById('joinBtn');
  const leaveBtn = document.getElementById('leaveBtn');
  const localV   = document.getElementById('local');
  const remoteV  = document.getElementById('remote');
  const statusEl = document.getElementById('status');

  let localStream = null;
  let pc = null;
  let ws = null;
  let paired = false;

  function setStatus(s){ statusEl.textContent = 'Status: ' + s; }

  async function startCamera(){
    try {
      localStream = await navigator.mediaDevices.getUserMedia({ video:true, audio:true });
      localV.srcObject = localStream;
      startBtn.disabled = true;
      joinBtn.disabled = false;
      setStatus('camera ready');
    } catch (e) {
      alert('Camera permission denied or no device: ' + e.message);
      setStatus('camera error');
    }
  }

  function connectWS(){
    if (ws && ws.readyState === WebSocket.OPEN) return;
    ws = new WebSocket(SIGNAL_SERVER);
    ws.onopen = ()=> { setStatus('connected to signaling server'); };
    ws.onclose = ()=> { setStatus('signaling disconnected'); };
    ws.onerror = (e)=> { console.error('WS err', e); setStatus('signaling error'); };
    ws.onmessage = async (ev) => {
      const msg = JSON.parse(ev.data);
      // types: waiting, paired, signal, peer-left
      if (msg.type === 'waiting') {
        setStatus('waiting for partner...');
      } else if (msg.type === 'paired') {
        setStatus('paired â€” starting WebRTC negotiation');
        startPeer(true); // initiator? We'll decide below
      } else if (msg.type === 'signal') {
        await handleSignal(msg.payload);
      } else if (msg.type === 'peer-left') {
        setStatus('Peer left');
        closePeer();
      }
    };
  }

  // Simple heuristic: the client that receives 'paired' and currently has no offer will act as 'caller'
  // We'll implement a call where the client that initiates the 'join' will create the offer.
  // To implement that correctly, server can tell who is initiator. Here we simply treat both sides same:
  let createdOffer = false;

  async function startPeer(isInitiator){
    if (!localStream) { alert('Start camera first'); return; }
    pc = new RTCPeerConnection(ICE_CONFIG);

    // add local tracks
    for (const t of localStream.getTracks()) pc.addTrack(t, localStream);

    pc.ontrack = (e) => {
      // set remote stream (may be more than one)
      remoteV.srcObject = e.streams[0];
      setStatus('Connected to peer');
    };

    pc.onicecandidate = (evt) => {
      if (evt.candidate && ws && ws.readyState === WebSocket.OPEN) {
        ws.send(JSON.stringify({ type:'signal', payload:{ type:'ice', candidate: evt.candidate } }));
      }
    };

    // create offer if this client is the one to start
    // We'll ensure exactly one side creates offer by the following convention:
    // The client that clicked "Find Random Partner" will send join; when paired, that same client becomes initiator.
    // So we track createdOffer boolean elsewhere.
    if (createdOffer) {
      const offer = await pc.createOffer();
      await pc.setLocalDescription(offer);
      ws.send(JSON.stringify({ type:'signal', payload:{ type:'sdp', sdp: pc.localDescription } }));
    }
    leaveBtn.disabled = false;
  }

  async function handleSignal(payload){
    if (!pc) {
      // If we get a signal and pc not created, create it and NOT create an offer (we will answer)
      createdOffer = false;
      await startPeer(false);
    }
    if (payload.type === 'sdp') {
      const desc = payload.sdp;
      if (desc.type === 'offer') {
        // set remote and create answer
        await pc.setRemoteDescription(new RTCSessionDescription(desc));
        const answer = await pc.createAnswer();
        await pc.setLocalDescription(answer);
        ws.send(JSON.stringify({ type:'signal', payload:{ type:'sdp', sdp: pc.localDescription } }));
      } else if (desc.type === 'answer') {
        await pc.setRemoteDescription(new RTCSessionDescription(desc));
      }
    } else if (payload.type === 'ice') {
      try {
        await pc.addIceCandidate(payload.candidate);
      } catch(e){ console.warn('ICE add failed', e); }
    }
  }

  function closePeer(){
    if (pc) {
      try { pc.getSenders().forEach(s => s.track && s.track.stop()); } catch {}
      try { pc.close(); } catch {}
      pc = null;
    }
    remoteV.srcObject = null;
    leaveBtn.disabled = true;
    joinBtn.disabled = false;
    createdOffer = false;
  }

  // UI handlers
  startBtn.onclick = startCamera;

  joinBtn.onclick = () => {
    if (!localStream) { alert('Start camera first'); return; }
    connectWS();
    // When the user clicks Join, this client will be the initiator for creating the offer
    createdOffer = true;
    // Wait until socket opens then send join
    const tryJoin = () => {
      if (ws && ws.readyState === WebSocket.OPEN) {
        ws.send(JSON.stringify({ type: 'join' }));
        setStatus('joining queue...');
        joinBtn.disabled = true;
      } else {
        setStatus('connecting to signaling server...');
        setTimeout(tryJoin, 300);
      }
    };
    tryJoin();
  };

  leaveBtn.onclick = () => {
    if (ws && ws.readyState === WebSocket.OPEN) {
      ws.send(JSON.stringify({ type: 'leave' }));
    }
    closePeer();
    setStatus('left');
  };

  // cleanup before closing page
  window.addEventListener('unload', () => {
    if (ws && ws.readyState === WebSocket.OPEN) ws.send(JSON.stringify({ type:'leave' }));
  });

  // optional: auto-start camera
  // await startCamera();

})();
</script>
</body>
</html>
