<!doctype html>
<html>
<head>
  <meta charset="utf-8" />
  <title>Random Video Chat - Tamil VM (Fixed)</title>
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <style>
    body{font-family:sans-serif;background:#111;color:#eee;margin:0;padding:0}
    #videoContainer{position:relative;width:100%;height:70vh;background:#000;display:flex;align-items:center;justify-content:center;overflow:hidden}
    video{width:100%;height:100%;object-fit:cover;background:#000}
    #localVideo{position:absolute;top:10px;right:10px;width:160px;height:120px;object-fit:cover;border:2px solid #fff;border-radius:8px;z-index:2}
    #waitingOverlay{position:absolute;inset:0;background:rgba(0,0,0,.72);display:flex;flex-direction:column;align-items:center;justify-content:center;gap:10px;z-index:1}
    .spinner{width:40px;height:40px;border:5px solid #999;border-top:5px solid #fff;border-radius:50%;animation:spin 1s linear infinite}
    @keyframes spin{0%{transform:rotate(0)}100%{transform:rotate(360deg)}}
    .controls{text-align:center;padding:14px}
    button{padding:10px 14px;margin:6px;border-radius:8px;border:0;color:#fff;cursor:pointer}
    #startBtn{background:#2563eb}#nextBtn{background:#10b981}#hangBtn{background:#ef4444}#muteBtn{background:#f59e0b}#camBtn{background:#8b5cf6}
    #status{display:block;margin-top:8px;color:#bbb}#timer{display:block;color:#aaa;margin-top:6px}
  </style>

  <!-- Firebase compat -->
  <script src="https://www.gstatic.com/firebasejs/9.22.2/firebase-app-compat.js"></script>
  <script src="https://www.gstatic.com/firebasejs/9.22.2/firebase-database-compat.js"></script>
</head>
<body>
  <h2 style="text-align:center;margin:12px 0">ðŸ”¥ Random Video - Tamil VM (Fixed)</h2>

  <div id="videoContainer">
    <video id="remoteVideo" autoplay playsinline></video>
    <video id="localVideo" autoplay muted playsinline></video>

    <div id="waitingOverlay">
      <div class="spinner"></div>
      <div id="waitingText">Idle â€” click "Find Partner"</div>
    </div>
  </div>

  <div class="controls">
    <button id="startBtn">Find Partner</button>
    <button id="nextBtn" disabled>Next</button>
    <button id="hangBtn" disabled>Hang Up</button>
    <button id="muteBtn" disabled>Mute</button>
    <button id="camBtn" disabled>Camera Off</button>
    <button id="fullscreenBtn">Fullscreen</button>
    <button id="themeBtn">Theme</button>

    <div id="status">Status: Idle</div>
    <div id="timer">Call Duration: 00:00</div>
  </div>

  <audio id="connectSound" src="https://www.myinstants.com/media/sounds/iphone-notification.mp3"></audio>

<script>
(async function () {
  // ---------- CONFIG: Option A (sample project) ----------
  const firebaseConfig = {
    apiKey: "AIzaSyAlWP5D79PsX29H0hIZlfvL0YV5Us7v5I4",
    authDomain: "sample-firebase-ai-app-1f408.firebaseapp.com",
    databaseURL: "https://sample-firebase-ai-app-1f408-default-rtdb.asia-southeast1.firebasedatabase.app",
    projectId: "sample-firebase-ai-app-1f408",
    storageBucket: "sample-firebase-ai-app-1f408.firebasestorage.app",
    messagingSenderId: "657942233322",
    appId: "1:657942233322:web:a8dd9896ca8cfccdbb5793"
  };
  firebase.initializeApp(firebaseConfig);
  const db = firebase.database();

  // ---------- UI ----------
  const localVideo = document.getElementById('localVideo');
  const remoteVideo = document.getElementById('remoteVideo');
  const waitingOverlay = document.getElementById('waitingOverlay');
  const waitingText = document.getElementById('waitingText');
  const startBtn = document.getElementById('startBtn');
  const nextBtn = document.getElementById('nextBtn');
  const hangBtn = document.getElementById('hangBtn');
  const muteBtn = document.getElementById('muteBtn');
  const camBtn = document.getElementById('camBtn');
  const fullscreenBtn = document.getElementById('fullscreenBtn');
  const themeBtn = document.getElementById('themeBtn');
  const statusEl = document.getElementById('status');
  const timerEl = document.getElementById('timer');
  const connectSound = document.getElementById('connectSound');

  // ---------- state ----------
  const clientId = 'c_' + Math.random().toString(36).slice(2,10);
  let queueKey = null;           // our queue node key
  let callId = null;             // current call id (calls/{callId})
  let isInitiator = false;
  let pc = null;
  let localStream = null;
  let localCandidatesRef = null;
  let remoteCandidatesRef = null;
  let callRef = null;
  let queueRef = db.ref('queue');
  let pairsRef = db.ref('pairs');
  let callsRootRef = db.ref('calls');
  const iceConfig = { iceServers: [{ urls: "stun:stun.l.google.com:19302" }] };

  let timerInterval = null;
  let startTime = null;

  // ---------- helpers ----------
  function setStatus(txt){ statusEl.textContent = 'Status: ' + txt; }
  function showOverlay(show, text=''){ waitingOverlay.style.display = show ? 'flex' : 'none'; waitingText.textContent = text; }
  function enableControls(connected){
    startBtn.disabled = connected;
    hangBtn.disabled = !connected;
    nextBtn.disabled = !connected;
    muteBtn.disabled = !connected;
    camBtn.disabled = !connected;
  }
  function startTimer(){
    startTime = Date.now();
    timerEl.textContent = 'Call Duration: 00:00';
    clearInterval(timerInterval);
    timerInterval = setInterval(()=> {
      const diff = Date.now() - startTime;
      const mins = String(Math.floor(diff/60000)).padStart(2,'0');
      const secs = String(Math.floor((diff%60000)/1000)).padStart(2,'0');
      timerEl.textContent = `Call Duration: ${mins}:${secs}`;
    }, 1000);
  }
  function stopTimer(){ clearInterval(timerInterval); timerEl.textContent = 'Call Duration: 00:00'; }

  // ---------- Media ----------
  async function getLocalStream(){
    if(localStream) return localStream;
    try {
      localStream = await navigator.mediaDevices.getUserMedia({ video: true, audio: true });
      localVideo.srcObject = localStream;
      return localStream;
    } catch(err){
      console.error('getUserMedia error',err);
      alert('Camera/mic access required.');
      throw err;
    }
  }

  // ---------- QUEUE / MATCHING ----------
  async function enterQueue(){
    // push our queue entry and set onDisconnect cleanup
    const newRef = queueRef.push();
    queueKey = newRef.key;
    await newRef.set({ id: clientId, ts: Date.now() });
    newRef.onDisconnect().remove();
    setStatus('Waiting for partner...');
    showOverlay(true, 'Waiting for partner...');
    watchQueue();
    watchPairForUs();
  }

  // When anyone pushes into queue, try to form a pair by writing to pairs/{otherKey}
  function watchQueue(){
    // Listen for new entries (others joining). When a new entry appears we attempt a transaction on pairs/{otherKey}
    queueRef.on('child_added', async snap => {
      try {
        if(!snap.exists()) return;
        const otherKey = snap.key;
        if(otherKey === queueKey) return; // ignore our own entry
        // Avoid pairing with ourselves (shouldn't happen)
        if(!queueKey) return;
        // Use transaction on pairs/{otherKey} to ensure only one partner pairs to that queue entry
        const pairNode = db.ref('pairs/' + otherKey);
        await pairNode.transaction(current => {
          if (current === null) {
            // create pair record linking otherKey and our queueKey
            return { a: otherKey, b: queueKey, createdAt: Date.now() };
          }
          // someone else already claimed it
          return;
        }, (err, committed, snapshot) => {
          if (err) {
            console.warn('pair transaction err', err);
            return;
          }
          if (committed && snapshot.exists()) {
            // We've successfully formed a pair (we are the initiator)
            // compute sorted id so both clients use same callId
            const ids = [otherKey, queueKey].sort();
            callId = `call_${ids[0]}_${ids[1]}`;
            isInitiator = true;
            // remove both queue entries (cleanup)
            db.ref('queue/' + otherKey).remove().catch(()=>{});
            db.ref('queue/' + queueKey).remove().catch(()=>{ queueKey = null; });
            startCall(callId);
          }
        });
      } catch(e){ console.error('watchQueue child_added error', e); }
    });
  }

  // If someone else created a pair referencing our queueKey, we should start the call (we're the responder)
  function watchPairForUs(){
    const myPairRef = db.ref('pairs/' + queueKey);
    myPairRef.on('value', snap=>{
      const val = snap.val();
      if(!val) return;
      // val contains {a: otherKey, b: ourQueueKey} OR vice versa
      if(!callId && val && (val.a === queueKey || val.b === queueKey)){
        // Determine partner's queue key
        const other = (val.a === queueKey) ? val.b : val.a;
        if(!other) return;
        const ids = [other, queueKey].sort();
        callId = `call_${ids[0]}_${ids[1]}`;
        isInitiator = false; // we respond
        // remove both queue entries
        db.ref('queue/' + other).remove().catch(()=>{});
        db.ref('queue/' + queueKey).remove().catch(()=>{ queueKey = null; });
        startCall(callId);
      }
    });
    myPairRef.onDisconnect().remove(); // cleanup pairs record if we disconnect while waiting (defensive)
  }

  // ---------- START / SIGNALING ----------
  async function startCall(id){
    try {
      await getLocalStream();
    } catch(e){ return; }

    setStatus('Starting call...');
    pc = new RTCPeerConnection(iceConfig);
    // add our tracks
    localStream.getTracks().forEach(t => pc.addTrack(t, localStream));

    pc.ontrack = e => {
      // first ontrack will carry remote stream
      if (e.streams && e.streams[0]) remoteVideo.srcObject = e.streams[0];
    };

    // handle remote candidate arrivals
    pc.onicecandidate = e => {
      // push our local candidates to localCandidatesRef
      if (e.candidate && localCandidatesRef) {
        localCandidatesRef.push(e.candidate.toJSON()).catch(()=>{});
      }
    };

    // listen for iceConnection changes to auto-hangup on disconnect/failure
    pc.oniceconnectionstatechange = () => {
      const st = pc.iceConnectionState;
      if (["failed","disconnected","closed"].includes(st)) {
        // cleanup
        hangUp();
      }
    };

    // prepare call node and candidate nodes
    callRef = db.ref('calls/' + id);
    const offerRef = callRef.child('offer');
    const answerRef = callRef.child('answer');

    // local/remote candidate refs (both sides read from the other's candidate list)
    localCandidatesRef = callRef.child(isInitiator ? 'offerCandidates' : 'answerCandidates');
    remoteCandidatesRef = callRef.child(isInitiator ? 'answerCandidates' : 'offerCandidates');

    // keep listeners limited: on child_added add candidate
    const remoteCandHandler = remoteCandidatesRef.on('child_added', snap => {
      const c = snap.val();
      if(!c) return;
      try { pc.addIceCandidate(new RTCIceCandidate(c)).catch(()=>{}); } catch(e){ console.warn('addIceCandidate err', e); }
    });

    // Also listen if the call node is deleted/cleared by other side -> hang up
    const callDeletedHandler = callRef.on('value', snap => {
      // if call node removed (null) -> hang up
      if (!snap.exists()){
        // cleanup
        hangUp();
      }
    });

    // OFFER / ANSWER flow
    if (isInitiator) {
      // create offer, save it, wait for answer
      const offer = await pc.createOffer();
      await pc.setLocalDescription(offer);
      await offerRef.set({ type: offer.type, sdp: offer.sdp });
      // listen for answer
      answerRef.on('value', async snap => {
        const data = snap.val();
        if (data && data.sdp && (!pc.remoteDescription || !pc.remoteDescription.type)) {
          try {
            await pc.setRemoteDescription(new RTCSessionDescription(data));
          } catch(e){ console.warn('setRemoteDescription (initiator) failed',e); }
        }
      });
    } else {
      // responder waits for offer, sets remote, creates answer
      offerRef.on('value', async snap => {
        const data = snap.val();
        if (data && data.sdp && (!pc.remoteDescription || !pc.remoteDescription.type)) {
          try {
            await pc.setRemoteDescription(new RTCSessionDescription(data));
            const answer = await pc.createAnswer();
            await pc.setLocalDescription(answer);
            await answerRef.set({ type: answer.type, sdp: answer.sdp });
          } catch(e){ console.warn('responder flow error', e); }
        }
      });
    }

    // Update UI
    enableControls(true);
    setStatus('Connected');
    showOverlay(false);
    startTimer();
    try { connectSound.currentTime = 0; connectSound.play().catch(()=>{}); } catch(e){}
  }

  // ---------- HANGUP / CLEANUP ----------
  async function hangUp(){
    // close peer connection
    try { if(pc) { pc.close(); } } catch(e){}

    // cleanup firebase entries related to this call (only if we created them or they exist)
    if (callId) {
      try {
        // remove only our candidate entries if any; safe to remove entire call node to fully clean
        await db.ref('calls/' + callId).remove().catch(()=>{});
      } catch(e){ console.warn('call remove err', e); }
    }
    // remove our queue entry if still present
    if (queueKey) {
      try { await db.ref('queue/' + queueKey).remove().catch(()=>{}); } catch(e){}
      queueKey = null;
    }

    // reset state
    pc = null;
    callId = null;
    isInitiator = false;
    localCandidatesRef = null;
    remoteCandidatesRef = null;
    callRef = null;

    enableControls(false);
    setStatus('Idle');
    showOverlay(true, 'Waiting for partner...');
    stopTimer();
  }

  // ---------- UI actions ----------
  startBtn.onclick = async () => {
    try {
      await getLocalStream();
    } catch(e){ return; }
    // ensure we aren't already in queue
    if (queueKey) {
      showOverlay(true, 'Already in queue...');
      return;
    }
    await enterQueue();
  };

  nextBtn.onclick = async () => {
    // hangup current call then re-enter queue
    await hangUp();
    // short delay so remote cleanup propagates
    setTimeout(()=> startBtn.click(), 250);
  };

  hangBtn.onclick = async () => {
    await hangUp();
  };

  muteBtn.onclick = () => {
    if(!localStream) return;
    const t = localStream.getAudioTracks()[0];
    if(!t) return;
    t.enabled = !t.enabled;
    muteBtn.textContent = t.enabled ? 'Mute' : 'Unmute';
  };

  camBtn.onclick = () => {
    if(!localStream) return;
    const t = localStream.getVideoTracks()[0];
    if(!t) return;
    t.enabled = !t.enabled;
    camBtn.textContent = t.enabled ? 'Camera Off' : 'Camera On';
  };

  fullscreenBtn.onclick = () => {
    const el = document.documentElement;
    if (!document.fullscreenElement) el.requestFullscreen().catch(()=>{});
    else document.exitFullscreen();
  };

  themeBtn.onclick = () => {
    const cur = document.body.getAttribute('data-theme') || 'dark';
    const nxt = cur === 'dark' ? 'light' : 'dark';
    document.body.setAttribute('data-theme', nxt);
    // colors aren't heavily themed in this snippet but toggles exist
  };

  // ---------- Unload cleanup ----------
  window.addEventListener('beforeunload', async () => {
    try {
      if (queueKey) await db.ref('queue/' + queueKey).remove().catch(()=>{});
      if (callId) await db.ref('calls/' + callId).remove().catch(()=>{});
    } catch(e){}
  });

  // initial UI
  enableControls(false);
  showOverlay(true, 'Idle â€” click "Find Partner"');
  setStatus('Idle');
})();
</script>
</body>
</html>
